# 1 Introduction

This document serves as the documentation for our group project in the Object-Oriented Programming in Java - Advanced Course. The project involves the development of a Java GUI application to interact with the RESTful API of a “drone simulation system.” Early on, we decided to give our application a shorter and more fitting name: [**DroneDeck**](https://github.com/Code-Hauptwache/DroneDeck).

The goal of DroneDeck is to provide a straightforward and user-friendly UI to visualize data generated by the drone simulation. We aim not only to satisfy the project requirements but also to create a modern-looking GUI that is easy to use and minimalistic. While the project is still in its early stages, this documentation will outline the goals, design considerations, and future steps for the application. Regular updates will be made as development progresses, reflecting any adjustments or improvements to the project.

# 2 Group Members

| Name | Main Responsibilities |
| --- | --- |
| Noah Gordon Müller | API Connectivity, Project Documentation |
| Zakaria Boujana | UI Design, GUI Development, Issue Management |
| Wontak Choi (former member) | Caching Data, Search Function |
| Damjan Luka Josic | Logo Design, Minor UI Adjustment, Documentation Support |

# 3 Project Documentation

In the following section, you will find a comprehensive project documentation that includes both a user handbook and a technical description of our application. The user handbook provides an overview of the application's functionality and how it is intended to be used, while the technical description delves into its inner workings, outlining the design choices, architecture, and implementation details. Additionally, this section explains how we met the various project requirements and the rationale behind key development decisions.

## 3.1 User Handbook

### 3.1.1 Introduction

Welcome to the User Handbook for **DroneDeck**! This guide will help you understand how to use the application, including navigation, key functionalities and troubleshooting common issues. DroneDeck is a **Java-based GUI application** designed to interact with a **drone simulation system** via a RESTful API, providing users with real-time drone data in an intuitive interface.

### 3.1.2 Installation & Start

**Note:** You must be inside the univerity network (either physically or via VPN using **FortiClient VPN**) to interact with the server.

**Requirements:**

- Java 23 or higher
- Internet connection (for API access)
- Operating System: Windows, MacOS or Linux

**Installation Steps:**

1. Download the application from https://github.com/Code-Hauptwache/DroneDeck/releases
2. Double-click the JAR file or run via command line in your environment:
    
    ```java
    java -jar DroneDeck.jar
    ```
    

**API Token Authentication**

- Upon starting the application for the first time, users will be prompted to enter their **API Token**.
- The API Token is provided via the univerity’s drone simulation system. Users must log in to the [**dronesim.facets-labs.com**](http://dronesim.facets-labs.com) website using their university credentials to retrieve their personal API Token.

**First-Time Authentication**

![image.png](attachment:9422075e-e32e-4e6e-9f9f-d27c39f4abc6:image.png)

1. When launching **DroneDeck** for the first time, the application will display a screen requesting the **API Token**.
2. Users must copy their API Token from the [**dronesim.facets-labs.com**](http://dronesim.facets-labs.com) portal and paste it into the input field.
3. Users then have the option to create a **password** that will be used for future logins.
4. Login in with the password will store the token on the device, encrypted with the chosen password.

**Returning User Login**

![image.png](attachment:59e87976-8ba0-4330-9978-52e5d0a9a1ad:image.png)

On subsequent launches, instead of re-entering the API Token, users will see a login screen requesting only their **password**.

- Entering the correct password will decrypt and retrieve the stored API Token automatically, allowing access to the application.
- Users can press Cancel on the password entry screen and will be redirected back to the initial token entry screen.
- If no token is saved, users must enter a valid API token to proceed.

### 3.1.3 Navigation & Key Features

**Home Screen**

- Once authenticated, the **DroneDeck Dashboard** is displayed.
- The **navigation bar** at the top allows switching between sections:
    - **Dashboard** - Monitor real-time drone data.
    - **Drone Catalog** - Browse available drone models.

**Main Functionalities**

**Dashboard (Real-Time-Data)**

![image.png](attachment:4537172f-04b1-49e4-b4ea-390fa41f174f:image.png)

- Live monitoring of all active drones.
- Displays battery status, speed, carriage type and serial number
- Accessing detailed view of drone information.

---

**Drone Catalog**

![image.png](attachment:7ebc1899-b012-4954-96d9-96c0a8dc3a84:image.png)

- Displays all available drone models.
- Accessing detailed view of drone information.

---

**Detailed Drone Card**

![image.png](attachment:12bb15e0-67d4-4ec4-97d3-37199b6d232c:image.png)

- Shows details such as location, weight, control range and more.
- [Graphical Component (comming soon)]
- **Timestamp Selection:** Users can navigate through historical drone data using the **Entry Timestamp Selector**:
    - **Dropdown Menu:** Select a specific time entry (sorted from latest to oldest).
    - **Navigation Buttons:**
        - `<<` Jump to the **oldest drone data**.
        - `<` Go **one entry back**.
        - `>` Go **one entry forward**.
        - `>>` Jump to the **latest drone data**.

---

**Search Bar**

- The **Search Bar** is located right under the navigation bar.
- Users can search for drones by ID, manufacturer or model.

---

**Theme Switching**

- The **Theme Switching Button** is located on the top right.
- Toggle between **Light Mode & Dark Mode.**
- The application automatically detects the system theme (OS theme) on startup and applies the corresponding mode.

---

### 3.1.4 Troubleshooting

**Common Issues & Fixes**

- **Network Acces Issue:** If you are unable to connect, ensure that you are inside the university network. If off-campus, use FortiClient VPN to establish a secure connection to the university’s network befor launching the application.
- **API Token Not Working:** Ensure you have an active internet connection and the correct token.
- **Application Not Starting:** Check if Java 23+ is installed.

## **3.2 Technical Documentation**

In the following, we will provide a small overview of the inner workings of our application. While we won’t go into every detail, we still want to cover the most important aspects. You will also find a list of all requirements, where and how they were implemented in our application, why they were used, and what advantages they provide.

### **3.2.1 Technical Overview**

Our application was written using **Java**. We used **Swing** to build our GUI and **FlatLaf** to provide a more modern look to Swing components. We also used **Ikonli** to provide scalable and customizable icons. Additionally, we created a [**public repository**](https://github.com/Code-Hauptwache/DroneDeck) for the development of our application, allowing us to collaborate more effectively and coordinate our development efforts.

We followed a specific naming approach for our classes and logic. All classes used for data manipulation, which the user cannot interact with directly, are called Services. Their responsibility lies in retrieving data from the API or files and transforming or calculating data, such as a drone’s average speed. The rest of our application consists of UI components. These UI components are responsible for hydrating themselves with the data they should display, using Services to fetch and transform the data accordingly.

### **3.2.2 Requirements**

Here you will find a list of all requirements and an example implementation we chose.

**Object-Orientation**

A lot of interfaces were used to facilitate clean code. For example, in the `DroneApiService`. Nearly all our services implement an interface of their own. We did this to easily change the implementation later on or have two slightly different implementations of the same logic. This allows us to quickly make technical changes in the future.

1. API Service Interface
    
    ```java
    // Location: src/main/java/services/DroneApi/IDroneApiService.java
    // Line 77
    public interface IDroneApiService {
    	  // ...
        
        ArrayList<Drone> getDrones() throws DroneApiException;
        
        // ...
    }
    ```
    
2. Implementation Example
    
    ```java
    // Location: src/main/java/services/DroneApi/DroneApiService.java
    // Line 15
    public class DroneApiService implements IDroneApiService {
        // Implementation with seven core methods for data fetching
    }
    
    ```
    

**Collections**
We tried to use the appropriate collections whenever possible. For example, we extensively used streams and lists in the `LocalSearchService.java:157`, which is responsible for enabling text search on specific fields of Drones and DroneTypes.

```java
// Location: src/main/java/dao/LocalDroneDao.java
// Lines 157-163
public List<DroneEntity> findDronesByKeyword(String keyword) {
	// ...
}
```

**Error Handling**

Whenever we catch an exception, we log it. We also implemented a custom exception: `DroneApiException.java`. This exception summarizes all HttpExceptions that can be thrown during data fetching. Now, we can differentiate between technical exceptions and `HttpExceptions` during data fetching.

```java
// Location: src/main/java/exceptions/DroneApiException.java
// Lines 10
public class DroneApiException extends Exception {
	// ...
}
```

**Streams and Files**

For this, we have two major examples. In the `ApiTokenStoreService.java:84`, we have logic to encrypt and save an ApiToken on the user's secondary memory. We do this by serializing an object and writing it to a file, and vice versa.

```java
// Location: src/main/java/services/ApiToken/ApiTokenStoreService.java
// Lines 113-136
public static void saveApiToken(String password) throws IOException{
    // Serialization and encryption implementation
}

```

In the `DroneDataCalculationService.java:124`, we implemented logic to calculate data not provided by the API. We use streams to easily aggregate information, such as the total traveled distance.

```java
// Location:src/main/java/services/DroneDataCalculation/DroneDataCalculationService.java
// Lines 122-134
private double calculateTravelDistance(ArrayList<DroneDynamics> droneDynamics) {
	List<Coordinate> coordinates = droneDynamics.stream()
	  .map(d -> new Coordinate(d.longitude, d.latitude))
	  .toList();
	  
	// ...    
}
```

**Threads**

In the same `DroneDataCalculationService.java:91`, we also use threads while fetching DroneDynamics. This improves performance when fetching a large number of DroneDynamics.

```java
// Location:src/main/java/services/DroneDataCalculation/DroneDataCalculationService.java
// Lines 90-120
private ArrayList<DroneDynamics> getDroneDynamicsMultiThreaded(int droneId) 
	throws DroneApiException 
{
	ExecutorService executorService = Executors.newFixedThreadPool(THREAD_NUM);
	
	// ...
}
```

**Clean Code**

Clean code principles demonstrated through:

- Clear naming conventions (Services, UI Components)
- Interface-based design
- Comprehensive JavaDoc documentation
- Logical package structure
- Single Responsibility Principle adherence

**Documentation**

Our documentation approach follows the project requirements:

1. JavaDoc Documentation

```java
// Location: src/main/java/services/DroneApi/DroneApiService.java
/**
 * Service responsible for handling all API communication.
 * Implements pagination and token-based authentication.
 */
public class DroneApiService implements IDroneApiService {
    /**
     * Retrieves drone dynamics for a specific drone with pagination support.
     * @param droneId The unique identifier of the drone
     * @param limit Maximum number of records to retrieve
     * @param offset Starting position for data retrieval
     * @return DroneDynamicsResponse containing the paginated data
     * @throws DroneApiException if API communication fails
     */
    public DroneDynamicsResponse getDroneDynamicsResponseByDroneId(String droneId, int limit, int offset) {
        // Implementation
    }
}

```

1. Comprehensive Logging

```java
// Location: src/main/java/services/LocalSearch/LocalSearchService.java
private static final Logger logger = Logger.getLogger(LocalSearchService.class.getName());

public void initLocalData() {
    logger.log(Level.INFO, "Initializing local data cache");
    try {
        // Implementation
    } catch (Exception e) {
        logger.log(Level.SEVERE, "Failed to initialize local data", e);
    }
}

```

Documentation Features:

- JavaDoc for all public methods
- Detailed package documentation
- Comprehensive exception documentation
- Logging for exceptional flows
- Debug information logging
- Performance monitoring logs

**Data Refresh**
To simplify data refresh, we have a `DataRefreshService` responsible for updating the Drone Dashboard and Drone detail views. The service therefore re-fetches the data every **300 seconds** and re-renders the appropriate components to display the updated information.

**Calculation of Data**

As required by the project description, we have implemented the calculation of the average speed and the total traveled distance. Due to performance constraints, both are only calculated for the latest 500 DroneDynamics. The calculated values for average speed and total traveled distance can be found on the Drone details view.

Additionally, we have implemented the calculation of the battery charge percentage. We also included a pie chart displaying the distribution of all drone statuses.

**Logging**
For logging, we chose java.util.logging, which we configure in `DroneDeck.java:63` and use throughout our application. Since we did not need to write logs to a file, we omitted this functionality. However, during development, the logging configuration can be easily adjusted as needed.

```java
// Location: src/main/java/DroneDeck.java
// Lines 63-84
private static void configureLogging() {
	// ...
}
```

### **3.2.3 Technical Details**

Here, you will find a brief overview of our Classes and Services. We won’t explain every piece of code since most of our code is documented using JavaDocs and is largely self-explanatory. However, we still wanted to provide an overview of the most important parts of our application.

**DroneApiService**

The DroneApiService is responsible for fetching all data from the API. It includes functions to retrieve all data from all GET endpoints of the API. The DroneApiService uses DTOs and GSON (a JSON serialization library) to deserialize HTTP responses into DTOs, providing a type-safe programming environment. This allows developers to receive warnings and errors from their IDEs, preventing bugs and problems down the line.

The DroneApiService itself is quite simple. At its core, we have seven private methods that handle data fetching for Drones, Drones by ID, DroneDynamics, DroneDynamics by Drone ID, DroneTypes, and DroneTypes by Drone ID. We also have a function to retrieve the "raw" response when getting DroneDynamics to obtain the total count of all DroneDynamics.

We provide a variety of public methods. When an endpoint has both a limit and an offset, we use method overloading to provide two versions: one where you can specify the limit and offset, and one where no parameters are required.

**ApiTokenStoreService**

This service is used to save an ApiToken to the user's HDD and encrypt it. This allows us and the user to remember only a simple, human-readable password used for encryption instead of the entire ApiToken. This service is primarily used by the ApiTokenService, which is responsible for handling the ApiToken during runtime.

**ApiTokenService**

This service is responsible for handling the ApiToken during runtime. Whenever an ApiToken is needed (e.g., to initiate a `DroneApiService` instance), it must be accessed through the ApiTokenService.

The method `getApiToken()` retrieves the ApiToken. First, it checks if an ApiToken is already loaded into memory. If it is, the method returns it. If not, the ApiTokenService attempts to retrieve the token. It first checks if a token is saved to the user's filesystem using the ApiTokenStoreService. If so, it prompts the user for a password to decrypt and load the token into memory. If none of this works, the user is asked to input an ApiToken manually.

The ApiTokenService also includes logic to set the ApiToken using an environment variable. This makes development and automated testing easier and faster.

**DroneDataCalculationService**

This service is responsible for calculating data that the API does not provide, such as travel distance and average speed. We achieve this by fetching the first 500 DroneDynamics records for a drone and calculating the distance between each set of coordinates.

For representing coordinates and their operations, we created a class called `Coordinate`. We limit the fetch to the first 500 DroneDynamics to avoid exceeding our API limit and to speed up data fetching and calculations. Our tests showed that using more than 500 DroneDynamics significantly slows down the process, taking several seconds to minutes when fetching all `DroneDynamics` of a drone.

**DataRefreshService**

The **DataRefreshService** is responsible for automatically refreshing drone data at regular intervals, ensuring the system always operates with the latest available information.

This service runs as a singleton, executing periodic data refresh cycles every 300 seconds (5 minutes). It is designed to be thread-safe using `ScheduledExecutorService` and includes an automatic retry mechanism with a 5-second delay in case of failure.

The refresh process consists of several key operations:

1. Fetching basic drone data
2. Pre-fetching drone dynamics data
3. Updating UI components such as the **Dashboard** and **Catalog**

To ensure smooth user experience, UI updates are performed on the **Event Dispatch Thread (EDT)**. The service also incorporates comprehensive error handling and logging, making it robust and reliable.

Additionally, **DataRefreshService** supports manual refresh triggering and ensures a graceful shutdown when the application exits.

Integration Points:

- **DroneController** – Responsible for data fetching
- **DroneDashboard** – UI updates
- **DroneCatalog** – UI updates
- **LocalDroneDao** – Local data access
- **IDroneApiService** – Fetching drone dynamics data

**LocalSearchService**

This is a simple service responsible for fetching Drones and DroneTypes and enabling text search over them. This service is also used to fetch `Dron`es and `DroneTypes` for the Catalog and Dashboard pages of our application.

### 3.2.4 Additional Features

Beyond the basic requirements, we implemented:

1. Battery Status Visualization

```java
// Location: src/main/java/ui/components/DroneVisualBatteryStatus.java
// Lines 13-130
public class DroneVisualBatteryStatus extends JComponent {
    // Visual battery status implementation
}
```

1. Drone Status Statistics

```java
// Location: src/main/java/ui/components/AllDronesStatusPieChartPanel.java
// Lines 1-31
public class AllDronesStatusPieChartPanel extends JPanel {
    // Statistical visualization implementation
}
```

These additional features enhance the user experience and provide valuable insights into drone fleet operations beyond the basic requirements.

### 3.2.5 Loading Progress and Logging System

### Loading Progress Tracking

The application implements a comprehensive loading progress system that provides:

- Detailed progress tracking during initialization
- Visual progress bar with status messages
- Synchronized UI and console logging
- Progress mapping between different loading stages
- Emoji-enhanced log messages for better readability

Loading stages breakdown:

1. Initial setup (0-30%):
    - API connection establishment (0-10%)
    - Basic drone information fetch (10-30%)
2. Data loading (30-95%):
    - Drone type information fetch (30-50%)
    - Data processing (50-85%)
    - Local storage operations (85-95%)
3. Completion (95-100%): Final initialization and UI updates

### Logging Implementation

The application uses java.util.logging for comprehensive logging across all services:

```java
private static final Logger logger = Logger.getLogger(ServiceName.class.getName());

// Information logging
logger.log(Level.INFO, "🔄 Starting periodic data refresh");

// Error logging with exception details
logger.log(Level.SEVERE, "❌ Failed to fetch drone data", exception);

// Progress information
logger.log(Level.INFO, "⏳ Dynamics update progress: 50.0% (5/10 drones)");
```

Key logging features:

- Hierarchical logging categories by package/class
- Multiple severity levels (INFO, WARNING, SEVERE, etc.)
- Exception stack trace preservation
- Performance monitoring logs
- Emoji usage for better log readability
- Synchronized logging for thread safety

Logging covers critical operations:

- Data refresh cycles
- API communication
- Error conditions and retries
- Performance metrics
- UI update events
- Service lifecycle events

# 4 Milestones

## 4.1 Milestone 1: Initial Setup and Foundation

For the first milestone, our primary goal was to get an overview of all the tasks we needed to complete and decide on the tools we would use for the project. After some discussion, we selected IntelliJ as our IDE for its modern and user-friendly UI, GitHub as our repository due to its free availability, widespread use, and robust features for planning and tracking progress, and Notion as a small "notebook" for documenting our project and ideas.

We set up an initial Java project and organized our GitHub repository to track our progress effectively. We assigned some initial tasks, such as creating a basic UI to display a window with some text and starting work on API connectivity. Both the API and UI tasks progressed quickly, and we were able to get them working early on.

Since one of our original members couldn’t register for the project, we were assigned another person with whom we immediately made contact and scheduled a team meeting.
In this first team meeting, we set up and installed all the tools we had decided on, on each of our computers, and gave some team members a small overview of them. We then made plans for our next meeting and assigned each person the task of creating a UI mockup, which we wanted to present and discuss. Between these two meetings, we also finalized the API connectivity and created a logo for our application.

In our second team meeting, we decided on our application logo and discussed our UI mockups. After we all had a basic understanding of what our UI should look like and what it should do, we created issues on GitHub for most of the tasks we needed to complete our project. We then decided to work on our assigned tasks over the holidays and hold another team meeting after the holidays.

To conclude this milestone, we decided to finalize our milestone document and hold a few small remote meetings to proofread and refine it. However, due to the holidays, we do not plan on taking on much more work at this stage. This approach allows us to ensure the quality of our documentation while also accommodating the reduced availability of team members during the holiday period. 

## 4.1 Milestone 1 Changelog

### **Everybody**

- **GUI Mockup Design**:
    - The team collaboratively created a mockup in Figma to visualize the GUI design.
    - The mockup emphasized a modern, minimalistic, and user-friendly interface.
    
    ![Group 26.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0f0681e9-e312-42e7-bb53-e8e6f5ae82d3/7bd19d10-06db-48e0-8082-7a6fd61a4880/Group_26.png)
    
- **Scrum-like Workflow:**
    - We have decided to use a Scrum-like workflow to collaborate in an easy and efficient manner.
    - This involves holding a meeting every 1–2 weeks to discuss current progress and assign tasks to one another.

### Zakaria

- **Repository Creation**
    - **What?**
        - A GitHub repository and project was established to host the project, manage code versions, and organize tasks.
        - Issues were created in the repository to track tasks and responsibilities.
    - **Why?**
        - To ensure effective collaboration, maintain a clear project structure, and track development progress.
        
        ![*Status as of 20.12.2024*](https://prod-files-secure.s3.us-west-2.amazonaws.com/0f0681e9-e312-42e7-bb53-e8e6f5ae82d3/9a0fb8ab-ba86-4ad8-a491-a91fc561732a/image.png)
        
        *Status as of 20.12.2024*
        
- **Documentation Management**
    - **What?**
        - A Notion workspace was set up to facilitate collaborative documentation and manage ideas.
    - **Why?**
        - To centralize information, streamline teamwork, and ensure everyone has easy access to updated documentation.
- **Theme Switching**
    - **What?**
        - Implemented a functional button for toggling between dark and light themes in the UI.
        - Leveraged Swing and FlatLaf to deliver a contemporary and customizable user experience.
    - **Why?**
        - To enhance user comfort, accommodate different visual preferences, and modernize the interface.
- **Add [Navigation Bar](https://github.com/Code-Hauptwache/DroneDeck/pull/36#issue-2753633278)**
    - **What?**
        - Implemented a `NavigationBar` component that allows users to switch between the Drone Catalog and Drone Dashboard pages.
        - Created buttons for "Catalog" and "Dashboard" within the `NavigationBar`.
        - Added functionality to highlight the selected button and update the displayed page accordingly.
        - Updated the `MainPanel` to handle page switching and keep track of the current page.
        - Added tests to verify button selection and page switching functionality.
    - **Why?**
        - To provide a user-friendly interface for navigating between different sections of the application.
        - To ensure that the navigation bar correctly updates the displayed page and highlights the selected button.
        - To improve the overall user experience by making navigation intuitive and visually clear.
- **Add Card Template Component**
    - **What?**
        - Added `CardTemplate` component to create a consistent look and feel for card-like components in the application. This component includes a title, subtitle, and content area, with a modern border and separator.
        - Added tests for `CardTemplate` to verify the creation of the component, the update of theme colors, and the update of all instances.
    - **Why?**
        - To provide a reusable template for creating individual card components with different content. This ensures a uniform appearance across the application, particularly for displaying information about drones in the Catalog and Dashboard pages. The `CardTemplate` component simplifies the process of adding new cards by standardizing the layout and styling, making it easier to maintain and update the UI.

### Gordon

- **API Connectivity**
    - **What?**
        - Implemented a `DroneApiService` to easily access data from the API in a type-safe manner.
    - **Why?**
        - To centralize and provide a solid, type-safe foundation for API access to streamline development and prevent unnecessary bugs further into development.
- **Writing the project documentation and the first milestone.**
    - **What?**
        - Creating the first draft of our project documentation.
        - Taking the project documentation from Notion and formatting it in Word to submit a clean document for the first milestone.
        - Each member then added the tasks they themselves worked on.
    - **Why?**
        - We decided to have ongoing project documentation.
        - While Notion has many great features for collaboration, its exporting options lack stylistic and formatting flexibility to create a professional-looking report.

### Wontak

- **API Data Caching**
    - **What?**
        - Serialized drone data received from the API and saved it as a `bin` file locally.
        - Ensured fast data loading and processing speed through serialization and deserialization processes.
        - Managed drone data files via file input/output operations, including logic to validate file integrity.
    - **Why?**
        - To enhance service reliability by enabling data utilization without network requests.
        - To efficiently store and manage data, preventing performance degradation even with large-scale data.
        - To reduce API usage, thereby achieving cost savings.
- **Search Functionality Implementation**
    - **What?**
        - Implemented a search feature to filter drone data stored locally based on specific conditions.
        - Designed the search logic as an interface to ensure easy access and extensibility for team members.
        - Returned search results to users as a list of drone data, dynamically changing based on conditions.
    - **Why?**
        - To provide users with fast and accurate access to the data they need.
        - To make the search logic extensible and maintainable through an interface-based design.
        - To enhance user experience and reduce data exploration time.

### Damjan

- **Logo Design**
    - **What?**
        - Created a minimalistic, modern logo for **DroneDeck**, designed to reflect the project's technological and innovative nature.
        - Ensured the logo works seamlessly in both light and dark themes for consistent visibility.
        - Delivered in scalable PNG and SVG formats, suitable for desktop app use.
    - **Why?**
        - A clear and recognizable logo strengthens the branding of the DroneDeck application.
        - The logo's adaptability to different themes and resolutions ensures a professional look across devices.
- **Automatic Theme Synchronization with System**
    - **What?**
        - Implemented functionality to automatically adjust the **DroneDeck** application's theme to match the system's current theme setting (light or dark mode).
        - The solution ensures seamless integration with the existing theme switch functionality of the app, dynamically changing the theme when the system setting changes.
    - **Why?**
        - This feature provides a straightforward and efficient way to enhance user experience by aligning the app's theme with the system’s theme setting.
        - The implementation avoids extensive custom solutions, ensuring robustness and reliability, while offering users a consistent and intuitive interface.

## Milestone 1: Summary Our Goals for the Next Milestone

Our goal for the next milestone is simple: get the “least viable” application working. This essentially involves incorporating all listed requirements into our application. Achieving this will allow us to have some free time during the study phase before the exams, focus on less critical but still desirable features, and create a buffer in case someone gets sick or we face other unforeseen challenges.

Nonetheless, we are pleased with the progress we have made so far. This is the first time we have worked together as a team, and we feel we’ve gotten to know each other well, which has helped us collaborate more effectively. We believe this growing familiarity and understanding within the team has made the development process smoother and more enjoyable

## 4.2 Milestone 2

As we outlined in the first milestone, the goal for the second milestone was to get the least viable application working. While we haven’t yet implemented every minor requirement, we’ve made significant progress toward achieving the broader goals for our application.

One of our primary tasks was completing the initial UI for the application. In the first milestone, we had successfully implemented API connectivity, but no substantial UI was ready in time. For this milestone, a major focus was on displaying real data retrieved from our API within a functional and accessible UI. Although we made minor adjustments to our original design plans, we opted for a simplified design approach to enhance the application's accessibility and user-friendliness.

Additionally, we implemented a search bar, enabling users to search through all available drones and calculate and display relevant drone data, such as the traveled distance. To achieve this, we leveraged the latitude and longitude data from recent drone dynamics, reversed their locations, and calculated the distance between each point before summing them up.

Another important accomplishment was securely handling the API token. Since our GitHub repository is public, we avoided storing the token directly in the repository by using environment variables during development. However, to improve the user experience and eliminate the need for setting environment variables each time the application is used, we implemented a feature allowing users to input the API token on application startup. This token is then securely stored on the user’s disk for future use.

Now that these key steps are finished, we’ve added several features and updates to bring the application closer to its final form. Below is a complete overview of what we accomplished during this milestone.

## 4.2 Milestone 2 Changelog

### Zakaria

- **Add [Dashboard Card Component](https://github.com/Code-Hauptwache/DroneDeck/pull/47)**
    - **What?**
        - Implemented `DroneDashboardCard` component to display real-time drone status and dynamic data in a card format.
        - Created `DroneDashboardCardDto` class to transfer data to the `DroneDashboardCard` component.
        - Added unit tests for `DroneDashboardCard` to verify its functionality and content.
        - Added functionality to show key metrics like battery level, Locatin, and current flight status.
    - **Why?**
        - To provide users with a clear and organized view of real-time drone information in the dashboard interface.
        - To enable quick monitoring of critical drone metrics and status updates through an intuitive card-based display.
- **Add [Catalog Card Component](https://github.com/Code-Hauptwache/DroneDeck/pull/52#issue-2763113318)**
    - **What?**
        - Implemented `DroneCatalogCard` class to represent a card with information about a drone.
        - Created `DroneCatalogCardDto` class to transfer data to the `DroneCatalogCard` component.
        - Added unit tests for `DroneCatalogCard` to verify its functionality and content.
        - Added functionality to show information about the avilable Drones like weight, max speed, and control range.
    - **Why?**
        - To provide users with an organized and intuitive way to browse available drones and their specifications in the catalog interface.
        - To ensure the `DroneCatalogCard` component works correctly and displays the expected content.
- **Add [Navigation from Dashboard to Detailed View](https://github.com/Code-Hauptwache/DroneDeck/pull/54#issue-2764202271)**
    - **What?**
        - Implemented the `DroneDetailedView` page to display detailed information about a drone.
        - Refactored the layout in the `MainPanel` to support overlays covering the entire UI.
        - Added navigation logic to switch from the `DashboardDroneCard` view to the `DroneDetailedView`.
    - **Why?**
        - To enhance user experience by providing intuitive navigation to detailed drone information.
        - To allow users to access comprehensive drone details directly from dashboard cards.
- **Add [Detailed Drone Information Page](https://github.com/Code-Hauptwache/DroneDeck/pull/56#issue-2765223216)**
    - **What?**
        - Implemented the `DroneDetailedView` component for comprehensive drone information display.
        - Created the `DroneDashboardDto` class to handle data transfer across dashboard components.
        - Enhanced unit tests to validate the `DroneDetailedView` functionality.
    - **Why?**
        - To offer users detailed drone insights through an intuitive interface.
        - To maintain data integrity across component interactions.
        - To ensure robust functionality through **thorough testing.**
- **Add [Search Bar for Dashboard and Catalog](https://github.com/Code-Hauptwache/DroneDeck/pull/64#issue-2777753749)**
    - **What?**
        - Implemented a unified search bar component for searching across both Dashboard and Catalog.
        - Added filtering functionality to display drone data based on user search input.
        - Replaced example data with live API data integration.
    - **Why?**
        - Enables users to quickly find and filter specific drone information.
        - Provides data from the API that gets updated when the application starts.
- **Add [Empty Card Component for Graphical Content](https://github.com/Code-Hauptwache/DroneDeck/pull/73#issue-2790212145)**
    - **What?**
        - Added `GraphicalCardTemplate` component to create a consistent look and feel for card-like components in the application. This component includes a title, and content area.
        - Added tests for `GraphicalCardTemplate` to verify the creation of the component, the update of theme colors, and the update of all instances.
    - **Why?**
        - To provide a reusable template for creating uniform card components with graphical content, ensuring consistency across the app. The `GraphicalCardTemplate` streamlines adding cards by standardizing layout and styling, simplifying UI maintenance.

### Gordon

- **Added Encrypted API Token Storage**
    - **What?**
        - Implemented a service for securely storing the user's API token.
        - The token is saved to the user's hard drive.
        - The token is encrypted using a password for secure storage.
    - **Why?**
        - To make the application easier to use. A password is easier to remember than an API token.
        - To ensure the API token is stored securely.
- **Added UI for Inputting API Token**
    - **What?**
        - When the user first starts the application, they are prompted for their API token.
        - The user can choose to save the token or not save it.
        - When starting the application with a saved API token, the user is prompted for their password.
    - **Why?**
        - Eliminates the need for users to set environment variables to securely configure the API token.
        - Speeds up the workflow and improves usability.
- Transfering Doumentation to Word and exporting as PDF
    - What?
        - Transfering the Documentation to a word document
        - Formatting said word document
        - Submitting Documentation as PDF
    - Why?
        - For easier collaboration we use Notion but since Notion dosn’t allow complex formating we transfer our Documentation to a word document

### Wontak

- **Developed TravelDistanceService Class**
    - **What?**
        - Developed the `TravelDistanceService` class to process dynamic drone data efficiently.
        - The class fetches data in batches of 100 using 5 separate threads, resulting in a total of 500 data points being retrieved from the API.
        - It performs haversine calculations to determine the distance for each data point and calculates the total distance.
    - **Why?**
        - The purpose of this class was to handle large-scale drone data efficiently by leveraging multi-threading for parallel processing.
        - This approach significantly reduces the time required for data processing and ensures accurate calculations for the total distance, meeting performance requirements.
- **Implemented DroneDashboardController for UI Support**
    - **What?**
        - Designed and developed the `DroneDashboardController` class to supply the `List<DroneDashboardDto>` data required for UI rendering.
        - The controller minimizes the UI's dependency on backend computations, such as total distance or current position.
        - Added pagination for fetching only the necessary data and utilized multi-threading to optimize the processing of DTO-specific calculations.
    - **Why?**
        - To enhance the modularity of the system by delegating dynamic calculations to the backend, ensuring the UI remains lightweight.
        - Pagination optimizes resource usage by retrieving only required data, while multi-threading ensures fast and efficient data preparation, supporting a better user experience.

### Damjan

- **Writing the Documentation for the Second Milestone**

## Milestone 2: Summary Our Goals for the Final **Submission**

One of the main challenges we faced during this milestone was developing the UI. Since none of us were familiar with Swing, creating a functional and visually appealing interface was more complex than we initially expected. Nevertheless, we made strong progress and have implemented nearly all the core requirements for the application.

With most of the essential features completed, the remaining critical task is to finalize error handling, one of the few outstanding requirements. Once this is done, we can dedicate our efforts to enhancing the application with optional improvements.

For the final submission, we aim to refine the UI, making it cleaner and more user-friendly. We also plan to improve the design of the API token input interface. If time permits, we’d like to add some extra features, such as interactive graphs, to present data in a more engaging way. These additions will make the application more polished while keeping it practical and accessible.

## 4.3 Final Submission

In our final submission, we are pleased to present the first fully functional version of our application. While we did not have the opportunity to implement every planned idea and feature due to time constraints, this release integrates all core functionalities into a presentable product. Key improvements include a refined and accessible user interface, secure API token management, interactive visualizations, and a periodic data refresh mechanism.

## 4.3 Final Submission Changelog

### Zakaria

- **Add [Graphical Pie Chart Component for Drone Status](https://github.com/Code-Hauptwache/DroneDeck/pull/75#issue-2795321549)**
    - **What?**
        - Added a pie chart component (`AllDronesStatusPieChartPanel`) to visualize drone statuses using data from `DroneStatusService`.
        - Included example classes to demonstrate setup and usage.
    - **Why?**
        - Provides a visually intuitive way to monitor drone statuses.
        - Ensures modular and reusable UI components with tested functionality.
- **Add [Support for Viewing Historical Drone Data in Detailed Drone View](https://github.com/Code-Hauptwache/DroneDeck/pull/81#issue-2811445765)**
    - **What?**
        - Integrated historical drone data viewing into `DroneDetailedView` using `EntryTimestampSelector`.
        - Provided example usage and unit tests for the new component.
    - **Why?**
        - Enables automatic review of past drone dynamics for trend analysis.
        - Improves troubleshooting by allowing users to access historical data without manual refresh.
- **Implement [Periodic Data Refresh](https://github.com/Code-Hauptwache/DroneDeck/pull/84#issue-2832695277)**
    - **What?**
        - Developed `DataRefreshService` as a singleton to refresh drone data automatically every 5 minutes.
        - Added error handling with an automatic retry mechanism for failed refresh attempts.
        - Created unit tests (`DataRefreshServiceTest`) to validate service functionality.
        - Integrated the service with components like `DroneController`, `DroneDashboard`, and `DroneCatalog` for seamless data updates.
        - Ensured thread-safe UI updates by handling refresh operations on the EDT.
    - **Why?**
        - Keeps drone data accurate and up-to-date without requiring manual refresh.
        - Enhances reliability with automatic error recovery and retry logic.
        - Maintains UI responsiveness and efficient resource usage.
        - Improves system monitoring and debugging with comprehensive logging.

# 5 Summary

Overall, we are very satisfied with our finished application. Despite encountering some challenges along the way, including losing team members who were unable to register for the exam, we successfully achieved our main goals. That being said, we have also identified numerous ways in which the application could be further improved in the future.

At the beginning of the project, we set out to design the application's UI and UX to be as simple and intuitive as possible while still providing all the necessary information. In the end, we believe we stayed true to this vision, delivering a modern, user-friendly, and powerful application that effectively meets its intended purpose.